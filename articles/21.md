
##### **第21章 Vue技术栈开发实战-Form表单**

- 基础表单

- 动态组件

- **iview - Form高级用法**动态表单

  


和普通表单不一样的地方：

没有 form 默认的 action , method ，表单提交不是原生的方式，是获取数据，通过ajax 提交



问题：

表单的验证、表单重置、表单提交，原理是什么？



调用 validate 方法，是对整个form 所有元素的验证，如果全部通过验证，true

```js
this.$refs[name].validate((valid) => {
  if (valid) {
    this.$Message.success('Success!');
  } else {
    this.$Message.error('Fail!');
  }
})
```



**动态表单！！！牛逼！！！**

运营自定义生成，动态表单

什么是动态表单？

非技术人员，运营，通过拖拽，或者 配置项，分发出去，动态生成表单

通过数据渲染表单页



动态组件，什么是动态组件？

这个组件，只要传一份数据，就能渲染成一个表单



formList 如何写？

我自己想到的：

```
{
	type: 'input'
	label: 
	name: 'name'
	rule:  验证 
	 
}

还有的：
key
1
```

难点1：

如何保证每个表单项，唯一性： 每个组件的 uid 是不同的



难点2：

如何显示不同类型的表单项？

使用 v-if ？

不可取

```js
<component :is="input"></compoent>
```

当 v-if  和 v-for 遇到一块儿时候，谁的优先级高？ v-for

所以把v-if 放到包裹 v-for 的外面



动态渲染了哪几种？

input、range、select、checkbox、radio



难点3

如何保存重置数据，初始值，保存在哪里



注意点:

form-item 必须 prop name， 什么意思

prop： 对应表单域 model 里的字段

```js
<template>
    <Form ref="formInline" :model="formInline" :rules="ruleInline" inline>
        <FormItem prop="user">
            <Input type="text" v-model="formInline.user" placeholder="Username">
                <Icon type="ios-person-outline" slot="prepend"></Icon>
            </Input>
        </FormItem>
        <FormItem prop="password">
            <Input type="password" v-model="formInline.password" placeholder="Password">
                <Icon type="ios-lock-outline" slot="prepend"></Icon>
            </Input>
        </FormItem>
        <FormItem>
            <Button type="primary" @click="handleSubmit('formInline')">Signin</Button>
        </FormItem>
    </Form>
</template>
<script>
    export default {
        data () {
            return {
                formInline: {
                    user: '',
                    password: ''
                },
                ruleInline: {
                    user: [
                        { required: true, message: 'Please fill in the user name', trigger: 'blur' }
                    ],
                    password: [
                        { required: true, message: 'Please fill in the password.', trigger: 'blur' },
                        { type: 'string', min: 6, message: 'The password length cannot be less than 6 bits', trigger: 'blur' }
                    ]
                }
            }
        },
        methods: {
            handleSubmit(name) {
                this.$refs[name].validate((valid) => {
                    if (valid) {
                        this.$Message.success('Success!');
                    } else {
                        this.$Message.error('Fail!');
                    }
                })
            }
        }
    }
</script>

```

能够动态渲染的数据：

```json
  [{
    name: 'name',
    type: 'i-input',
    value: '',
    label: '姓名',
    rule: [
      { required: true, message: 'The name cannot be empty', trigger: 'blur' }
    ]
  },
  {
    name: 'range',
    type: 'slider',
    value: [ 10, 40 ],
    range: true,
    label: '范围'
  },
  {
    name: 'sex',
    type: 'i-select',
    value: '',
    label: '性别',
    children: {
      type: 'i-option',
      list: [
        { value: 'man', title: '男' },
        { value: 'woman', title: '女' }
      ]
    }
  },
  {
    name: 'education',
    type: 'radio-group',
    value: 1,
    label: '学历',
    children: {
      type: 'radio',
      list: [
        { label: 1, title: '本科' },
        { label: 2, title: '研究生' },
        { label: 3, title: '博士' }
      ]
    }
  },
  {
    name: 'skill',
    type: 'checkbox-group',
    value: [],
    label: '技能',
    children: {
      type: 'checkbox',
      list: [
        { label: 1, title: 'Vue' },
        { label: 2, title: 'Nodejs' },
        { label: 3, title: 'MySql' }
      ]
    }
  },
  {
    name: 'inWork',
    type: 'i-switch',
    value: true,
    label: '在职'
  }]
```



问题：

错误保存到对象中，

```
 for (let key in err) {
 	this.errorStore[key] = err[key]
 }
```



focus 事件没有触发，使用 focus.native 

原因：有的组件中没有 focus 事件，可能叫 onfocus 或者 onchange 等。






##### **第22章 Vue技术栈开发实战-权限控制**

- 简单权限方案
- 动态挂载路由
- 页面和组件级别控制



第一种方法

在router.js 文件中，路径对象的meta中配置，是一个数组，表示当前这个页面是哪些用户组可以浏览

可以是一个字符串，比如，'admin-user' 或者是一个 code 

```js
{
  path:
  name:
  meta: {
    access: ['super_admin'],
    icon: ''
  }
}

store.dispatch('getUserInfo').then(user => {
  if(canTurnTo(to.name, user.access, routes)) next()
  else next({replace: true, name: 'error_401'})
})
```

缺点：

当用户组的数量变大，几十，上百种权限，前端配置会非常痛苦

前端要陪每一个路由项的 meta acess字段



第二种方式：

使用过滤的方式，获取可显示列表

后端返回的，组件级别的权限，页面级别的权限

这种方式：每个个路由必须要有name，而且不能重复

```js
export const authorization = () => {
  return {
    code: 200,
    data: {
      token: 'xxx',
      rules: {
        page: {
          home: true,
          home_index: true,
          about: true,
          argu: true,
          count_to: true,
          menu_page: true,
          upload: true,
          form: false,
          folder_tree: true,
          table_page: true,
          params: true,
          component: true,
          render_page: true,
          split_pane: true,
          parent: true,
          child: true,
          named_view: true,
          store: true,
          main: true
        },
        component: {
          edit_button: true,
          publish_button: false
        }
      }
    },
    mes: ''
  }
}
```

不需要权限控制的 路径，单独摘出来

根据后端返回，添加，routerMap(需要权限访问的所有路径集合)  到 routers 中来



思路：

在路由收尾中，获取当前权限能让问的 routers 对象数组，添加到 router 对象中

```js
// routerMap 动态路由表，rules 后端返回
routerList = getAccesRouterList(routerMap, rules)

// 注意带 * 的路由项要放在最后
 state.routers = routerList.concat(routes)

store.dispatch('concatRoutes', rules).then(routers => {
          router.addRoutes(clonedeep(routers))
          next({ ...to, replace: true })
        }).catch(() => {
          next({ name: 'login' })
        })
```



#### 什么意思？

```
next({ ...to, replace: true })
```




一直以来，我也知道可以通过vue-router官方提供的一个api-->[addRoutes](https://router.vuejs.org/zh/api/#router-addroutes)可以实现路由添加的功能，动态添加更多的路由规则。参数必须是一个符合 routes 选项要求的数组，事实上就也就实现了用户权限。



常见的几种方式：

直接单独配置，然后确定用户是否拥有该权限，利用数组方法concat拼接到其他路由配置当中。

```
let rs = routes
if (+id === 1) { // id为1时，该用户拥有所有权限
  rs = routes.concat(asyncRoute)
}
```

亦或者，在meta属性里面添加参数以确定是否需要鉴权：

```js
 [
  {
    path: '/users',
    name: 'Users',
    component: () => import('@/views/Users'),
    meta: {
      title: '用户管理',
      icon: 'user',
      auth: true
    }
  }
]
const routes = [].filter(item => !item.meta.auth)

router.addRoutes(deepclone( routers )) // 注意这里，要做深拷贝，不能好自己修改 routers 中的？？？why? 不在在 store 外修改 module 中的对象

因为 routers 在 store 中使用了，不能在store外面操作store的变量，需要写在 mutation 中
```



2. 当meta 过多不行，如何做？动态路由

注意点：

path: '*'  这个路由对象，一定要写在其他路由对象的后面



3. 我就不明白，为啥所有的	请求操作，在 store中做？ 

```
因为把 可以渲染的路由，存在state中了，而且可渲染的路由对象是动态获取的，所以需要放在 actions 中
```



4. 除了显示页面，rules 后端返回数据还可以控制某个页面，按钮的显示

```js
rules: {
        page: {
          home: true,
          home_index: true,
          store: true,
          main: true
        },
        component: {
          edit_button: true,
          publish_button: false
        }
      }

<Button v-if="rules.edit_button">编辑</Button>
<Button v-if="rules.publish_button">发布</Button>
```





##### **第23章 Vue技术栈开发实战-Icon组件**

- Unicode&Symbol
- font-class
- 封装单色和多色Icon组件



 unicode\class\symbol  三种方式

从iconfont 下载的文件，需要用的哪些？几个demo 不要，剩下的都是需要的



class 和 svg 差不多，不过svg 类名前面多了 #

而且svg自带颜色

```html
<svg class="iconfont-svg" aria-hidden="true" style="font-size: 70px;">
      <use xlink:href="#icon-shouye"></use>
</svg>
    
<i class="iconfont icon-shouye"></i> 
```

封装 icon 组件

```
icon-class
	class、大小、颜色
icon-svg
	class、大小
```

为什么直接 import，注册，会报错呢？

单个页面注册：

```js

<my-icon icon="shouye5" :size="40" color="red"></my-icon>
<my-svg icon="shouye5" :size="50"></my-svg>

import MyIcon from '_c/icon-font'
import MySvg from '_c/icon-svg'
```

全局注册，所有页面都能用

```js
import IconFont from '_c/icon-font'
import IconSvg from '_c/icon-svg'

Vue.component('icon-font', IconFont)
Vue.component('icon-svg', IconSvg)
```



##### **第24章 Vue技术栈开发实战-大数据量性能优化**

- 列表优化
- 大型表单优化
- 表格优化



问题1

如何模拟大数据量

```js
export const doCustomTimes = (times, callback) => {
  let i = -1
  while (++i < times) {
    callback(i)
  }
}

```



插件：

virtualList

接受参数，每一行的高度，你需要渲染的条数

原理：

没看明白，通过控制 padding-top  和 padding-bottom 控制可视区域

是内容替换还是 其他部分隐藏，隐藏不会啊，只会渲染 2n条数据

内容替换？ 替换成 padding 区域内的内容？



select、表单、checkbox 、table、不给数据添加get\setter

preventExtension





##### **第25章 Vue技术栈开发实战-多Tab页开发**

- 根据路由列表生成菜单
- 多标签实现
- 菜单、URL和标签联动



**1. 背景知识：**

tab 组件  http://v1.iviewui.com/components/tabs

点击插插按钮，样式是 card 类型

```html
<template>
    <Tabs type="card" closable @on-tab-remove="handleTabRemove">
        <TabPane label="标签一" v-if="tab0">标签一的内容</TabPane>
        <TabPane label="标签二" v-if="tab1">标签二的内容</TabPane>
        <TabPane label="标签三" v-if="tab2">标签三的内容</TabPane>
    </Tabs>
</template>
<script>
    export default {
        data () {
            return {
                tab0: true,
                tab1: true,
                tab2: true
            }
        },
        methods: {
            handleTabRemove (name) {
                this['tab' + name] = false;
            }
        }
    }
</script>

```



card组件 http://v1.iviewui.com/components/card

可以通过slot 配置title,  title 区域和 content 区域，有明显的分隔符

```html
<template>
    <Card style="width:350px">
        <p slot="title">
            <Icon type="ios-film-outline"></Icon>
            Classic film
        </p>
        <a href="#" slot="extra" @click.prevent="changeLimit">
            <Icon type="ios-loop-strong"></Icon>
            Change
        </a>
        <ul>
            <li v-for="item in randomMovieList">
                <a :href="item.url" target="_blank">{{ item.name }}</a>
                <span>
                    <Icon type="ios-star" v-for="n in 4" :key="n"></Icon><Icon type="ios-star" v-if="item.rate >= 9.5"></Icon><Icon type="ios-star-half" v-else></Icon>
                    {{ item.rate }}
                </span>
            </li>
        </ul>
    </Card>
</template>

```



**左侧菜单栏y轴滚动**

y轴上可滚动。想要滚动条，但是不想看到他，**把左侧菜单往右拉20px**

当static(非浮动、非定位）元素的margin-top/margin-left被赋予负值时，元素将被拉进指定的方向。

但如果你设置margin-bottom/right为负数，元素并不会如你所想的那样向下/右移动，而是将后续的元素拖拉进来，覆盖本来的元素。

如果没有设定width属性，设定负margin-left/right会将元素拖向对应的方向，并增加宽度，此时的margin的作用就像padding一样。

```
.ivu-layout-sider-children{
      margin-right: -20px;
      overflow-y: scroll;
      overflow-x: hidden;
    }
```





**3. 页面之间的逻辑：**

sideMenu、tabs、router-view 之间的逻辑



tablist:  已经打开的tab 数组

路由name 可能会重复，如何确定tablist 每一个item 的key?

key 可以是一个对象！



基本逻辑：

+ 单击菜单项，tabs 判断重复，添加，router-view显示

+ 点击tabs，菜单栏高亮，router-view 显示

+ 监听route 输入，对应tabs、菜单项

  

1. 点击左侧 siderbar ，通过 push 方法，跳转到新页面
2. 在首页 中  watch router 对象变化，如果变化，更新 tablist
3. 判断当前文件路径否已经存在，不存在，添加到 tablist 数组中
4. sidemenu点击谁，当前tabs 组件，应该显示谁的内容
5. 点击 tab 页面，左侧 死的bar 和 route 会发生相应变化
   
	```
	1. handleClickTab 我没搞懂，这个id 是啥，从哪儿来?
	
	2. 菜单栏：openNames
	getOpenArrByName
	使用some 遍历的好处，如果return true 结束遍历
	
   
   当展开菜单数据变化，在nextTick 中更新
   watch: {
       openNames () {
         this.$nextTick(() => {
           this.$refs.menu.updateOpened()
         })
       }
     },
   
   3. 点击跳转，id 转 route 对象，然后使用push 跳转
   ```
   
6. 点击叉掉按钮，当前路由回退到哪个页面？



问题：

为啥子 给 tab 绑定 value， 下面的 router-view 就跳转到相应页面？？？

​	其实是router-view 中做的

​	tab的改变，不会影响 content 区域内容的变化

​	只是为了改变当前 tab 项内容 



监听路由的变化

​	如果是二级路由，怎么跳转

​			table 中，随机生成 id , 跳转，每次打开一个新tab

​	如果是路由带query ，怎么跳转？



3. 如何判断，当前路由已存在？

遍历tabs 中的路由列表，每一项和当前路由对比，看是否相等

判断两个路由相等，name相同， param 相同（这个好理解，是对象，判断每一项相等）

但是 query 也能按照对象的比较方法比较？？？奇怪！

```js
export const routeEqual = (route1, route2) => {
  const params1 = route1.params || {}
  const params2 = route2.params || {}
  const query1 = route1.query || {}
  const query2 = route2.query || {}
  return route1.name === route2.name && objEqual(params1, params2) && objEqual(query1, query2)
}
```

判断两个对象是否相等：

```
对象长度是否相等，遍历keys， 是否每一项 item 相等。

其实这个up主写的不对，如果有重复的，不行，最好先排序，然后比较

let a = {name: 123, name:123}
let b = {name: 123, age: 123}

function equal(obj1, obj2) {
  const keysArr1 = Object.keys(obj1)
   console.log(keysArr1)
  const keysArr2 = Object.keys(obj2)
  if (keysArr1.length !== keysArr2.length) return false
  else if (keysArr1.length === 0 && keysArr2.length === 0) return true
 
  else return !keysArr1.some(key => {
  	console.log(key)
  	return obj1[key] !== obj2[key]
  })
}

let c = equal(a, b)
```



如何，点击左侧菜单项，跳转到对应的页面？

```js
on-select	选择菜单（MenuItem）时触发	name

<Menu ref="menu" :active-name="$route.name" :open-names="openNames" v-show="!collapsed" width="auto" theme="dark" @on-select="handleSelect">
```

如何，点击左侧的菜单，对应的tabs高亮？

```js
value	当前激活 tab 面板的 name，可以使用 v-model 双向绑定数据
每个 tabpan 的name 是对应的路由名即可，value为当前路由

<Tabs value="name1">
  <TabPane label="标签一" name="name1">标签一的内容</TabPane>
  <TabPane label="标签二" name="name2">标签二的内容</TabPane>
  <TabPane label="标签三" name="name3">标签三的内容</TabPane>
</Tabs>
    
```

需求：如果路由中，query不同，params不同，但是name相同，打开不同tab

但是感觉这种写法不好，为什么不直接排序后序列化呢？

这样在逆操作中也很好把控。

```
所以，tabsValue  和 tabpane name 都是，name+query+params 构成的
```

测试

```
let obj = {name:123, age:456}
function getKeyValueArr(obj) {
  let arr = []
  Object.entries(obj).sort((a, b) => {
    return a[0] - b[0]
  }).forEach(([ _key, _val ]) => {
    arr.push(_key, _val)
  })
  return arr
}
```





##### **第26章 Vue技术栈开发实战-项目部署**

- 项目配置注意点
- Jenkins配置
- Nginx配置