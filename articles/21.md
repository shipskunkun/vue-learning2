
##### **第21章 Vue技术栈开发实战-Form表单**

- 基础表单

- 动态组件

- **iview - Form高级用法**动态表单

  


和普通表单不一样的地方：

没有 form 默认的 action , method ，表单提交不是原生的方式，是获取数据，通过ajax 提交



问题：

表单的验证、表单重置、表单提交，原理是什么？



调用 validate 方法，是对整个form 所有元素的验证，如果全部通过验证，true

```js
this.$refs[name].validate((valid) => {
  if (valid) {
    this.$Message.success('Success!');
  } else {
    this.$Message.error('Fail!');
  }
})
```



**动态表单！！！牛逼！！！**

运营自定义生成，动态表单

什么是动态表单？

非技术人员，运营，通过拖拽，或者 配置项，分发出去，动态生成表单

通过数据渲染表单页



动态组件，什么是动态组件？

这个组件，只要传一份数据，就能渲染成一个表单



formList 如何写？

我自己想到的：

```
{
	type: 'input'
	label: 
	name: 'name'
	rule:  验证 
	 
}

还有的：
key
1
```

难点1：

如何保证每个表单项，唯一性： 每个组件的 uid 是不同的



难点2：

如何显示不同类型的表单项？

使用 v-if ？

不可取

```js
<component :is="input"></compoent>
```

当 v-if  和 v-for 遇到一块儿时候，谁的优先级高？ v-for

所以把v-if 放到包裹 v-for 的外面



动态渲染了哪几种？

input、range、select、checkbox、radio



难点3

如何保存重置数据，初始值，保存在哪里



注意点:

form-item 必须 prop name， 什么意思

prop： 对应表单域 model 里的字段

```js
<template>
    <Form ref="formInline" :model="formInline" :rules="ruleInline" inline>
        <FormItem prop="user">
            <Input type="text" v-model="formInline.user" placeholder="Username">
                <Icon type="ios-person-outline" slot="prepend"></Icon>
            </Input>
        </FormItem>
        <FormItem prop="password">
            <Input type="password" v-model="formInline.password" placeholder="Password">
                <Icon type="ios-lock-outline" slot="prepend"></Icon>
            </Input>
        </FormItem>
        <FormItem>
            <Button type="primary" @click="handleSubmit('formInline')">Signin</Button>
        </FormItem>
    </Form>
</template>
<script>
    export default {
        data () {
            return {
                formInline: {
                    user: '',
                    password: ''
                },
                ruleInline: {
                    user: [
                        { required: true, message: 'Please fill in the user name', trigger: 'blur' }
                    ],
                    password: [
                        { required: true, message: 'Please fill in the password.', trigger: 'blur' },
                        { type: 'string', min: 6, message: 'The password length cannot be less than 6 bits', trigger: 'blur' }
                    ]
                }
            }
        },
        methods: {
            handleSubmit(name) {
                this.$refs[name].validate((valid) => {
                    if (valid) {
                        this.$Message.success('Success!');
                    } else {
                        this.$Message.error('Fail!');
                    }
                })
            }
        }
    }
</script>

```

能够动态渲染的数据：

```json
  [{
    name: 'name',
    type: 'i-input',
    value: '',
    label: '姓名',
    rule: [
      { required: true, message: 'The name cannot be empty', trigger: 'blur' }
    ]
  },
  {
    name: 'range',
    type: 'slider',
    value: [ 10, 40 ],
    range: true,
    label: '范围'
  },
  {
    name: 'sex',
    type: 'i-select',
    value: '',
    label: '性别',
    children: {
      type: 'i-option',
      list: [
        { value: 'man', title: '男' },
        { value: 'woman', title: '女' }
      ]
    }
  },
  {
    name: 'education',
    type: 'radio-group',
    value: 1,
    label: '学历',
    children: {
      type: 'radio',
      list: [
        { label: 1, title: '本科' },
        { label: 2, title: '研究生' },
        { label: 3, title: '博士' }
      ]
    }
  },
  {
    name: 'skill',
    type: 'checkbox-group',
    value: [],
    label: '技能',
    children: {
      type: 'checkbox',
      list: [
        { label: 1, title: 'Vue' },
        { label: 2, title: 'Nodejs' },
        { label: 3, title: 'MySql' }
      ]
    }
  },
  {
    name: 'inWork',
    type: 'i-switch',
    value: true,
    label: '在职'
  }]
```



问题：

错误保存到对象中，

```
 for (let key in err) {
 	this.errorStore[key] = err[key]
 }
```



focus 事件没有触发，使用 focus.native 

原因：有的组件中没有 focus 事件，可能叫 onfocus 或者 onchange 等。






##### **第22章 Vue技术栈开发实战-权限控制**

- 简单权限方案
- 动态挂载路由
- 页面和组件级别控制



第一种方法

在router.js 文件中，路径对象的meta中配置，是一个数组，表示当前这个页面是哪些用户组可以浏览

可以是一个字符串，比如，'admin-user' 或者是一个 code 

```js
{
  path:
  name:
  meta: {
    access: ['super_admin'],
    icon: ''
  }
}

store.dispatch('getUserInfo').then(user => {
  if(canTurnTo(to.name, user.access, routes)) next()
  else next({replace: true, name: 'error_401'})
})
```

缺点：

前端要陪每一个路由项的 meta acess字段



第二种方式：

使用过滤的方式，获取可显示列表

后端返回的，组件级别的权限，页面级别的权限

```js
export const authorization = () => {
  return {
    code: 200,
    data: {
      token: 'xxx',
      rules: {
        page: {
          home: true,
          home_index: true,
          about: true,
          argu: true,
          count_to: true,
          menu_page: true,
          upload: true,
          form: false,
          folder_tree: true,
          table_page: true,
          params: true,
          component: true,
          render_page: true,
          split_pane: true,
          parent: true,
          child: true,
          named_view: true,
          store: true,
          main: true
        },
        component: {
          edit_button: true,
          publish_button: false
        }
      }
    },
    mes: ''
  }
}
```

不需要权限控制的 路径，单独摘出来

根据后端返回，添加，routerMap(需要权限访问的所有路径集合)  到 routers 中来



entries 返回什么东西？

```js
if (Object.entries(rules).every(item => item[1])) {
          routerList = routerMap
        }


Object.entries({
  home: true,
  home_index: true}) 
  
  =
  
  [['home', true], ['home_index', true]]
```



#### 什么意思？

```
next({ ...to, replace: true })
```




一直以来，我也知道可以通过vue-router官方提供的一个api-->[addRoutes](https://router.vuejs.org/zh/api/#router-addroutes)可以实现路由添加的功能，动态添加更多的路由规则。参数必须是一个符合 routes 选项要求的数组，事实上就也就实现了用户权限。



常见的几种方式：

直接单独配置，然后确定用户是否拥有该权限，利用数组方法concat拼接到其他路由配置当中。

```
let rs = routes
if (+id === 1) { // id为1时，该用户拥有所有权限
  rs = routes.concat(asyncRoute)
}
```

亦或者，在meta属性里面添加参数以确定是否需要鉴权：

```js
 [
  {
    path: '/users',
    name: 'Users',
    component: () => import('@/views/Users'),
    meta: {
      title: '用户管理',
      icon: 'user',
      auth: true
    }
  }
]
const routes = [].filter(item => !item.meta.auth)

router.addRoutes(deepclone( routers )) // 注意这里，要做深拷贝，不能好自己修改 routers 中的？？？why?

因为 routers 在 store 中使用了，不能在store外面操作store的变量，需要写在 mutation 中
```



2. 当meta 过多不行，如何做？动态路由

注意点：

path: '*'  这个路由对象，一定要写在其他路由对象的后面



3. 我就不明白，为啥所有的	请求操作，在 store中做？ 

```
因为把 可以渲染的路由，存在state中了，而且可渲染的路由对象是动态获取的，所以需要放在 actions 中
```



4. 除了显示页面，rules 后端返回数据还可以控制某个页面，按钮的显示

```js
rules: {
        page: {
          home: true,
          home_index: true,
          store: true,
          main: true
        },
        component: {
          edit_button: true,
          publish_button: false
        }
      }

<Button v-if="rules.edit_button">编辑</Button>
<Button v-if="rules.publish_button">发布</Button>
```





##### **第23章 Vue技术栈开发实战-Icon组件**

- Unicode&Symbol
- font-class
- 封装单色和多色Icon组件



 unicode\class\symbol  三种方式

从iconfont 下载的文件，需要用的哪些？几个demo 不要，剩下的都是需要的



class 和 svg 差不多，不过svg 类名前面多了 #

而且svg自带颜色

```html
<svg class="iconfont-svg" aria-hidden="true" style="font-size: 70px;">
      <use xlink:href="#icon-shouye"></use>
</svg>
    
<i class="iconfont icon-shouye"></i> 
```

封装 icon 组件

```
icon-class
	class、大小、颜色
icon-svg
	class、大小
```

为什么直接 import，注册，会报错呢？

单个页面注册：

```js

<my-icon icon="shouye5" :size="40" color="red"></my-icon>
<my-svg icon="shouye5" :size="50"></my-svg>

import MyIcon from '_c/icon-font'
import MySvg from '_c/icon-svg'
```

全局注册，所有页面都能用

```js
import IconFont from '_c/icon-font'
import IconSvg from '_c/icon-svg'

Vue.component('icon-font', IconFont)
Vue.component('icon-svg', IconSvg)
```



##### **第24章 Vue技术栈开发实战-大数据量性能优化**

- 列表优化
- 大型表单优化
- 表格优化



问题1

如何模拟大数据量

```js
export const doCustomTimes = (times, callback) => {
  let i = -1
  while (++i < times) {
    callback(i)
  }
}

```



插件：

virtualList

接受参数，每一行的高度，你需要渲染的条数

原理：

没看明白，通过控制 padding-top  和 padding-bottom 控制可视区域

是内容替换还是 其他部分隐藏，隐藏不会啊，只会渲染 2n条数据

内容替换？ 替换成 padding 区域内的内容？



select、表单、checkbox 、table、不给数据添加get\setter

preventExtension





##### **第25章 Vue技术栈开发实战-多Tab页开发**

- 根据路由列表生成菜单
- 多标签实现
- 菜单、URL和标签联动



y轴上可滚动。想要滚动条，但是不想看到他，**把左侧菜单往右拉20px**

当static(非浮动、非定位）元素的margin-top/margin-left被赋予负值时，元素将被拉进指定的方向。

但如果你设置margin-bottom/right为负数，元素并不会如你所想的那样向下/右移动，而是将后续的元素拖拉进来，覆盖本来的元素。

如果没有设定width属性，设定负margin-left/right会将元素拖向对应的方向，并增加宽度，此时的margin的作用就像padding一样。

```
.ivu-layout-sider-children{
      margin-right: -20px;
      overflow-y: scroll;
      overflow-x: hidden;
    }
```







##### **第26章 Vue技术栈开发实战-项目部署**

- 项目配置注意点
- Jenkins配置
- Nginx配置